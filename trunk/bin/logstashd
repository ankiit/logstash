#!/usr/bin/env ruby

$: << File.join(File.dirname(__FILE__), "..")

require 'rubygems'
require 'lib/net/servers/indexer'
require 'lib/net/servers/parser'
require 'logger'
require 'optparse'

$progname = $0.split(File::SEPARATOR).last
$version = "0.3"
$logger = Logger.new(STDOUT)
$logger.level = Logger::INFO
$logger.progname = $progname
$logger.datetime_format = "%Y-%m-%d %H:%M:%S"

def main(args)
  Thread::abort_on_exception = true

  options = parse_options(args)
  children = {}

  if options[:logfile]
    logfd = File.open(options[:logfile], "a")
    $stdout.reopen(logfd)
    $stderr.reopen(logfd)
  else 
    # Require a logfile for daemonization
    if options[:daemonize]
      $stderr.puts "Daemonizing requires you specify a logfile (--logfile), " \
                   "none was given"
      return 1
    end
  end

  if options[:daemonize]
    fork and exit(0)

    # Copied mostly from  Daemons.daemonize, but since the ruby 1.8 'daemons' 
    # and gem 'daemons' have api variances, let's do it ourselves since nobody
    # agrees.

    trap("SIGHUP", "IGNORE")
    ObjectSpace.each_object(IO) do |io|
      # closing STDIN is ok, but keep STDOUT and STDERR
      # close everything else
      next if [STDOUT, STDERR].include?(io)
      begin
        unless io.closed?
          io.close
        end
      rescue ::Exception
      end
    end
  end

  if options[:pidfile]
    File.open(options[:pidfile], "w+") { |f| f.puts $$ }
  end

  if options[:indexer]
    pid = fork do
        $0 = "logstashd (indexer)"
      indexer = LogStash::Net::Servers::Indexer.new(options[:config],
                                                    $logger)
      indexer.run
      exit(0)
    end
    $logger.info "starting indexer (pid #{pid})"
    children[pid] = :indexer
  end

  if options[:parsers] > 0
    1.upto(options[:parsers]) do |i|
      pid = fork do
        $0 = "logstashd (parser)"
        parser = LogStash::Net::Servers::Parser.new(options[:config],
                                                    $logger)
        parser.run
        exit(0)
      end
      $logger.info "starting parser #{i}/#{options[:parsers]} (pid #{pid})"
      children[pid] = :parser
    end
  end

  $0 = "logstashd (supervisor)"
  dying = false
  Signal.trap("INT") do
    children.keys.each { |pid| Process.kill("TERM", pid) rescue nil }
    Process.waitall
    File.unlink(config[:pidfile])
    exit(5)
  end

  Signal.trap("TERM") do
    dying = true
    children.keys.each { |pid| Process.kill("TERM", pid) rescue nil }
    Process.waitall
    exit(5)
  end

  # We do this lame loop instead of "Process.waitall" because of a bug
  # in ruby 1.8.5 related to handling SIGTERM.
  while children.keys.length > 0
    pid = Process.waitpid(-1, Process::WNOHANG)
    if pid and !dying
      $logger.fatal "pid #{pid} died unexpectedly (#{children[pid]}), " \
                    "initiating shutdown"
      Process.kill("TERM", $$)
    end
    sleep(5)
  end

  return 0
end

def parse_options(args)
  options = {:indexer => true,
             :parsers => 1,
             :parserset => false,
             :config => nil,
             :daemonize => true,
             :pidfile => nil,
            }

  opts = OptionParser.new do |opts|
    opts.banner = "Usage: logstashd [options] configfile"
    opts.version = $version

    opts.on("-d", "--debug", "Enable debug output") do |x|
      $logger.level = Logger::DEBUG
    end

    opts.on("-I", "--disable-indexer",
            "Disable indexer (default enabled)") do |x|
      options[:indexer] = false
    end

    opts.on("-p", "--parsers COUNT", Integer,
            "Number of parsers to run (default 1)") do |x|
      raise(ArgumentError, "parser count must be >=0") if x < 0
      options[:parsers] = x
      if options[:parserset]
        $stderr.puts "can only specify -p N or -P once"
        exit(1)
      end
      options[:parserset] = true
    end

    opts.on("-P", "--disable-parser", "Disable parser") do |x|
      options[:parsers] = 0
      if options[:parserset]
        $stderr.puts "can only specify -p N or -P once"
        exit(1)
      end
      options[:parserset] = true
    end

    opts.on("--pidfile FILE", "Path to pidfile") do |x|
      options[:pidfile] = x
    end

    opts.on("-f", "--foreground", "Do not daemonize") do |x|
      options[:daemonize] = false
    end

    opts.on("-h", "--help", "Show this help message") do |x|
      puts opts
      exit(0)
    end

    opts.on("-l FILE", "--logfile FILE", "File path to put logs") do |x|
      options[:logfile] = x
    end
  end

  begin
    opts.order!(args)
  rescue
    $stderr.puts "#{$progname}: #{$!}"
    $stderr.puts opts
    exit(1)
  end

  if args.length != 1
    $stderr.puts "#{$progname}: must specify exactly one config file"
    $stderr.puts opts
    exit(1)
  end
  options[:config] = args.shift

  return options
end

exit main(ARGV)

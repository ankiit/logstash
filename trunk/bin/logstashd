#!/usr/bin/env ruby

$: << File.join(File.dirname(__FILE__), "..")

require 'rubygems'
require 'lib/net/servers/indexer'
require 'lib/net/servers/parser'
require 'logger'
require 'optparse'
require 'lib/program'

$progname = File.basename($0)
$version = "0.3"
$logger = Logger.new(STDOUT)
$logger.level = Logger::INFO
$logger.progname = $progname
$logger.datetime_format = "%Y-%m-%d %H:%M:%S"

class LogStash::Daemon < LogStash::Program
  def start_indexer
    pid = fork do
      $0 = "logstashd (indexer)"
      indexer = LogStash::Net::Servers::Indexer.new(@options[:config],
                                                    $logger)
      indexer.run
      exit(0)
    end
    $logger.info "starting indexer (pid #{pid})"
    @children[pid] = :indexer
  end

  def start_parsers
    1.upto(@options[:parsers]) do |i|
      pid = fork do
        $0 = "logstashd (parser)"
        parser = LogStash::Net::Servers::Parser.new(@options[:config],
                                                    $logger)
        parser.run
        exit(0)
      end
      $logger.info "starting parser #{i}/#{@options[:parsers]} (pid #{pid})"
      @children[pid] = :parser
    end
  end

  def run
    @children = {}
    super

    start_indexer if @options[:indexer]
    start_parsers if @options[:parsers] > 0

    $0 = "logstashd (supervisor)"

    termination_handler do
      @children.keys.each { |pid| Process.kill("TERM", pid) rescue nil }
    end

    puts "Children: #{@children.inspect}"

    # We do this lame loop instead of "Process.waitall" because of a bug
    # in ruby 1.8.5 related to handling SIGTERM.
    
    while @children.keys.length > 0
      # Ruby 1.8.5 has a bug with signal and syscall handlers.
      if RUBY_VERSION == "1.8.5"
        pid = Process.waitpid(-1, Process::WNOHANG)
      else
        pid = Process.waitpid(-1, 0)
      end

      if pid and dying?
        $logger.fatal "pid #{pid} died unexpectedly (#{@children[pid]}), " \
                      "initiating shutdown"
        Process.kill("TERM", $$)
      end

      if RUBY_VERSION == "1.8.5"
        sleep(5)
      end
    end

    return 0
  end # def run
end # class LogStash::Daemon

def main(args)
  options = parse_options(args)
  logstashd = LogStash::Daemon.new(options)
  return logstashd.run
end

def parse_options(args)
  options = {:indexer => true,
             :parsers => 1,
             :parserset => false,
             :config => nil,
             :daemonize => true,
             :pidfile => nil,
            }

  opts = OptionParser.new do |opts|
    opts.banner = "Usage: logstashd [options] configfile"
    opts.version = $version

    opts.on("-d", "--debug", "Enable debug output") do |x|
      $logger.level = Logger::DEBUG
    end

    opts.on("-I", "--disable-indexer",
            "Disable indexer (default enabled)") do |x|
      options[:indexer] = false
    end

    opts.on("-p", "--parsers COUNT", Integer,
            "Number of parsers to run (default 1)") do |x|
      raise(ArgumentError, "parser count must be >=0") if x < 0
      options[:parsers] = x
      if options[:parserset]
        $stderr.puts "can only specify -p N or -P once"
        exit(1)
      end
      options[:parserset] = true
    end

    opts.on("-P", "--disable-parser", "Disable parser") do |x|
      options[:parsers] = 0
      if options[:parserset]
        $stderr.puts "can only specify -p N or -P once"
        exit(1)
      end
      options[:parserset] = true
    end

    opts.on("--pidfile FILE", "Path to pidfile") do |x|
      options[:pidfile] = x
    end

    opts.on("-f", "--foreground", "Do not daemonize") do |x|
      options[:daemonize] = false
    end

    opts.on("-h", "--help", "Show this help message") do |x|
      puts opts
      exit(0)
    end

    opts.on("-l FILE", "--logfile FILE", "File path to put logs") do |x|
      options[:logfile] = x
    end
  end

  begin
    opts.order!(args)
  rescue
    $stderr.puts "#{$progname}: #{$!}"
    $stderr.puts opts
    exit(1)
  end

  if args.length != 1
    $stderr.puts "#{$progname}: must specify exactly one config file"
    $stderr.puts opts
    exit(1)
  end
  options[:config] = args.shift

  return options
end

exit main(ARGV)

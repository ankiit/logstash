#summary Discussion of the network protocol design
#labels Phase-Design

= Network Design =

= Transport =

== Why AMQP? ==

AMQP gives us lots of things without having to reinvent them:
  * message persistence outside of the client
  * broadcast messages
  * message acking
  * round robin / load balancing

It's also easy to proxy emssages from one message broker to another, allowing for easy funneling of message from client to broker to broker to server, through firewalls, without too much mess or network topology changes.

  * Message Acknowledgement. We want messages to be consumed and removed only when they have been processed with reasonable success. If one of our processes reads a message and dies before responding, that message stays in the queue.

  * Broadcast. Because we want to scale to many indexers, parsers, and agents, we need some way to query for a what is available. AMQP broadcasts (topics) are an excellent way to do . Broadcasting on the network layer, instead of over AMQP, would only stay on the local network or require multicast routing, both of which are inconvenient or impossible depending on who runs your network and where your systems live.

  * Round Robin / Load Balancing. If you have N subscribers to a queue, each message goegs to only one subscriber. This means we can have N log parsers all listening to the same queue to parse logs, all sharing the input load. This lets us both scale horizontally and support single nodes dropping out unexpectedly.

== Why not Thrift? ==

Thrift gets us none of the above, requiring us to implement them all. More code equals more bugs, and bugs in your network/messaging layer cause all kinds of sadness.

Thrift also doesn't support streaming, so if we wanted to split a large response into multiple messages (to provide responsive search experience), we'd have to implement that ourselves.



= Message Encoding =

== Why JSON? ==

Because it's simple and fast to encode/decode. Comparing 'to_json' and Marshal speeds in Ruby shows them to be pretty similar, and JSON is parseable in just about every language.

== Why not Thrift? ==

We could use Thrift, but at time of writing we cannot use Thrift over AMQP easily or speedily. I tried using Thrift with a StringIO-backed transport, but this was 60x slower than JSON, most likely due to StringIO sucking in Ruby.

== Why not Protocol Buffers ==

At time of writing, protocol buffers were not very mature outside of Google.
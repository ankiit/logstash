#summary Discussion of the network protocol design

= Network Design =

= Transport =

== Why AMQP? ==

AMQP gives us lots of things without having to reinvent them:
* message persistence outside of the client
* broadcast messages
* message acking

It's also easy to proxy emssages from one message broker to another, allowing for easy funneling of message from client to broker to broker to server, through firewalls, without too much mess or network topology changes.

* Message Acknowledgement. We want messages to be consumed and removed only when they have been processed with reasonable success. If one of our processes reads a message and dies before responding, that message stays in the queue.

* Broadcast. Because we want to scale to many indexers, parsers, and agents, we need some way to query for a what is available. AMQP broadcasts (topics) are an excellent way to do . Broadcasting on the network layer, instead of over AMQP, would only stay on the local network or require multicast routing, both of which are inconvenient or impossible depending on who runs your network and where your systems live.

== Why not Thrift? ==

Thrift gets us none of the above, requiring us to implement them all. More code equals more bugs, and bugs in your network/messaging layer cause all kinds of sadness.

= Message Encoding =

== Why JSON? ==

Because it's simple and fast to encode/decode. Comparing 'to_json' and Marshal speeds in Ruby shows them to be pretty similar, and JSON is parseable in just about every language.

== Why not Thrift? ==

We could use Thrift, but at time of writing we cannot use Thrift over AMQP easily or speedily. I tried using Thrift with a StringIO-backed transport, but this was 60x slower than JSON, most likely due to StringIO sucking in Ruby.

* Why not Protocol Buffers?

At time of writing, protocol buffers were not very mature outside of Google.
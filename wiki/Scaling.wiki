#summary Discussion about how the service will horizontally scale to deal with storage problems and real-time indexing speed.
#labels Phase-Deploy,Phase-Design

= Introduction =

There are two major driving requirements for being able to scale:

 * rate of indexing new log messages
 * backend storage for indexes

Since we're using message bus technology, scaling horizontally is easy (message-wise). Most brokers will treat multiple subscribers to the same queue in a round-robin fashion. This makes running multiple parses and indexers trivial.

The `logstashd` daemon provides both indexer and parser services, but they do not necessarily have to be on the same machine.

= Parser =

The parser is mostly CPU bound (grok parsing, Ruby strptime, general string I/O). You can run multiple parsers on the same machine (1 per core is reasonable). To control the number of parsers, use the `-p` flag to `logstashd`. If you want to run a `logstashd` that _only_ does parsing, use the `-I` flag to disable the indexer. Parsers are forked at the process level (because Ruby multi-threading doesn't really scale -- there is a global interpreter lock). The parsers all subscribe to the `logstash` queue (which the agent sends data to). Once they finish parsing a log line, data is sent to the `logstash-index` queue.

= Indexer =

The indexer is a consumer of CPU and I/O (throughput & space usage) for writing new logs and searching existing logs. Each indexer must have it's *own* `logstash_dir` defined in a config file; multiple indexers cannot read/write from the same ferret index. Multiple indexers may live on the same host (with different `logstash_dir`s, of course) or on different hosts. This means that log storage is also distributed (if there are 10 indexers running, 10 consecutive log lines might be on 10 different hosts). The search client will query all indexers and collate the results by date. If you want to run an indexer by itself without any parsers, use the `-p 0` flag to `logstashd`.

= Broker =

You may find the actual message broker as a choke point in your LogStash infrastructure. For this reason, we recommend running Rabbit MQ, which supports a "cluster" mode across multiple hosts.

= Search Notes =

Traditionally, ferret itself does the "merging" of results from multiple indexes. But since our indexes may be on different machines, and we are communicating with each index through a message bus, we must do the merging of results on the search client side.

This prevents us from doing "score-based" sorting (a feature of ferret; scores are assigned to results based on how closely they match the query). We think this is probably an OK thing; we figure the most useful usage of a product like this is range based with a date filter (i.e. show me all apache GET requests between this Monday and Wednesday). The searching agent can easily merge the results and sort by `@DATE`. There are still scores associated with each document, but they are only relevant to the documents from the same index, so it would be a mistake (search quality wise) to merge all of the results together and sort by score (or even show the score).

= Data =

(I removed the existing data, since so much has changed since then, but we need some real-life results.)